{
    "name": "Main Telegram Dispatcher v2",
    "nodes": [
        {
            "parameters": {
                "updates": [
                    "message"
                ],
                "additionalFields": {
                    "download": true,
                    "imageSize": "large"
                }
            },
            "id": "telegram-trigger",
            "name": "Listen for incoming events",
            "type": "n8n-nodes-base.telegramTrigger",
            "position": [
                0,
                400
            ],
            "webhookId": "322dce18-f93e-4f86-b9b1-3305519b7834",
            "typeVersion": 1,
            "credentials": {
                "telegramApi": {
                    "id": "EW2xjt48g5VAJ0M2",
                    "name": "Telegram account"
                }
            }
        },
        {
            "parameters": {
                "jsCode": "// ==========================================\n// NODE: Parse Telegram Message\n// Chu·∫©n h√≥a input cho AI Agent v√† subworkflows\n// ==========================================\n\nconst item = $input.first();\nconst root = item?.json ?? {};\nconst msg = root.message ?? root;\n\n// Text/caption\nconst text = (msg.text ?? msg.caption ?? '').toString();\n\n// Default output\nlet type = 'unknown';\nlet fileId = null;\nlet fileName = null;\nlet mimeType = null;\nlet fileSize = null;\n\n// Helpers\nconst getLowerName = (name) => (name ?? '').toString().toLowerCase();\nconst isAudioExt = (n) =>\n  n.endsWith('.m4a') || n.endsWith('.mp3') || n.endsWith('.wav') || \n  n.endsWith('.aac') || n.endsWith('.ogg') || n.endsWith('.flac') || n.endsWith('.oga');\nconst isTextExt = (n) => n.endsWith('.md') || n.endsWith('.txt');\nconst isVideoExt = (n) => n.endsWith('.mp4') || n.endsWith('.mov') || n.endsWith('.avi') || n.endsWith('.mkv');\nconst isImageExt = (n) => n.endsWith('.jpg') || n.endsWith('.jpeg') || n.endsWith('.png') || n.endsWith('.webp');\n\ntry {\n  // Voice note\n  if (msg.voice?.file_id) {\n    type = 'audio';\n    fileId = msg.voice.file_id;\n    fileName = 'voice_' + Date.now() + '.oga';\n    mimeType = msg.voice.mime_type ?? 'audio/ogg';\n    fileSize = msg.voice.file_size ?? null;\n\n  // Audio (music/podcast)\n  } else if (msg.audio?.file_id) {\n    type = 'audio';\n    fileId = msg.audio.file_id;\n    fileName = msg.audio.file_name ?? 'audio_' + Date.now() + '.mp3';\n    mimeType = msg.audio.mime_type ?? 'audio/mpeg';\n    fileSize = msg.audio.file_size ?? null;\n\n  // Video\n  } else if (msg.video?.file_id) {\n    type = 'video';\n    fileId = msg.video.file_id;\n    fileName = msg.video.file_name ?? 'video_' + Date.now() + '.mp4';\n    mimeType = msg.video.mime_type ?? 'video/mp4';\n    fileSize = msg.video.file_size ?? null;\n\n  // Photo (array nhi·ªÅu size - l·∫•y size l·ªõn nh·∫•t)\n  } else if (Array.isArray(msg.photo) && msg.photo.length) {\n    type = 'photo';\n    const best = msg.photo[msg.photo.length - 1];\n    fileId = best?.file_id ?? null;\n    fileName = 'photo_' + Date.now() + '.jpg';\n    mimeType = 'image/jpeg';\n    fileSize = best?.file_size ?? null;\n\n  // Document (m4a/mp3/pdf/zip/md/txt...)\n  } else if (msg.document?.file_id) {\n    fileId = msg.document.file_id;\n    fileName = msg.document.file_name ?? 'file_' + Date.now();\n    mimeType = msg.document.mime_type ?? 'application/octet-stream';\n    fileSize = msg.document.file_size ?? null;\n\n    const n = getLowerName(fileName);\n    if (isAudioExt(n)) type = 'audio';\n    else if (isTextExt(n)) type = 'text';\n    else if (isVideoExt(n)) type = 'video';\n    else if (isImageExt(n)) type = 'photo';\n    else type = 'document';\n\n  // Plain text (Check for Google Docs Link)\n  } else if (text) {\n    const docMatch = text.match(/docs\\.google\\.com\\/document\\/d\\/([a-zA-Z0-9_-]+)/);\n    if (docMatch && docMatch[1]) {\n      type = 'text';\n      root.googleDocId = docMatch[1];\n    } else {\n      type = 'text';\n    }\n  }\n} catch (e) {\n  type = 'unknown';\n}\n\n// Output chu·∫©n cho AI Agent v√† subworkflows\nreturn [{\n  json: {\n    // Lo·∫°i n·ªôi dung\n    type: type,\n    \n    // N·ªôi dung vƒÉn b·∫£n (text ho·∫∑c caption)\n    text: text,\n    googleDocId: root.googleDocId || null,\n    title: text.split('\\n')[0]?.slice(0, 120) || fileName?.replace(/\\.[^/.]+$/, '') || '',\n\n    content: text,\n    \n    // Th√¥ng tin file (ƒë·ªÉ truy·ªÅn sang subworkflow)\n    fileId: fileId,\n    fileName: fileName,\n    mimeType: mimeType,\n    fileSize: fileSize,\n    \n    // Metadata ƒë·ªÉ g·ª≠i ph·∫£n h·ªìi\n    chatId: msg.chat?.id ?? null,\n    messageId: msg.message_id ?? null,\n    userId: msg.from?.id ?? null,\n    userName: msg.from?.first_name ?? 'User'\n  }\n}];"
            },
            "type": "n8n-nodes-base.code",
            "typeVersion": 2,
            "position": [
                224,
                400
            ],
            "id": "parse-message",
            "name": "Parse Telegram Message"
        },
        {
            "parameters": {
                "model": "gpt-4o-mini",
                "options": {
                    "maxTokens": 4000,
                    "temperature": 0.3
                }
            },
            "id": "openai-model",
            "name": "OpenAI Chat Model",
            "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
            "position": [
                448,
                640
            ],
            "typeVersion": 1,
            "credentials": {
                "openAiApi": {
                    "id": "7Apw8wl9s10GnA8d",
                    "name": "OpenAi account"
                }
            }
        },
        {
            "parameters": {
                "promptType": "define",
                "text": "={{ JSON.stringify($json) }}",
                "options": {
                    "systemMessage": "B·∫°n l√† AI Agent ƒëi·ªÅu ph·ªëi n·ªôi dung t·ª´ Telegram sang website DangTyn8n (GitHub Pages).\n\n## INPUT\nB·∫°n s·∫Ω nh·∫≠n JSON t·ª´ node tr∆∞·ªõc v·ªõi c√°c field:\n- type: \"text\" | \"audio\" | \"video\" | \"photo\" | \"document\" | \"unknown\"\n- text: n·ªôi dung vƒÉn b·∫£n ho·∫∑c caption\n- title: ti√™u ƒë·ªÅ r√∫t g·ªçn t·ª´ text\n- fileId, fileName, mimeType, fileSize (n·∫øu c√≥ file)\n- chatId, messageId, userId, userName\n\n## TOOLS C√ì S·∫¥N\n1. **Blog Publisher v2**: Xu·∫•t b·∫£n b√†i blog l√™n GitHub Pages\n   - D√πng khi: type = \"text\" HO·∫∂C file l√† .md/.txt\n   - Input c·∫ßn truy·ªÅn: title, content, fileId (n·∫øu c√≥), fileName, chatId\n\n2. **Podcast Publisher v2**: Xu·∫•t b·∫£n podcast episode\n   - D√πng khi: type = \"audio\" (voice, .m4a, .mp3, .wav...)\n   - Input c·∫ßn truy·ªÅn: fileId, fileName, title (t·ª´ caption/text), chatId\n\n## QUY T·∫ÆC CH·ªåN TOOL\n- type = \"text\" ‚Üí Blog Publisher v2\n- type = \"audio\" ‚Üí Podcast Publisher v2\n- type = \"document\" v·ªõi .md/.txt ‚Üí Blog Publisher v2\n- type = \"document\" v·ªõi audio ‚Üí Podcast Publisher v2\n- type = \"video\" / \"photo\" ‚Üí Tr·∫£ l·ªùi: \"üì∏ ƒê√£ nh·∫≠n media. Hi·ªán ch∆∞a c√≥ tool x·ª≠ l√Ω video/·∫£nh.\"\n- type = \"unknown\" ‚Üí H·ªèi: \"B·∫°n mu·ªën publish blog hay podcast?\"\n\n## QUAN TR·ªåNG\n- Lu√¥n truy·ªÅn ƒê·∫¶Y ƒê·ª¶ c√°c field: fileId, fileName, title, content, chatId\n- Kh√¥ng b·ªãa link. Ch·ªâ tr·∫£ link n·∫øu tool output tr·∫£ v·ªÅ.\n- M·ªói l·∫ßn x·ª≠ l√Ω ch·ªâ g·ªçi 1 tool.\n- Sau khi tool ch·∫°y xong, tr·∫£ l·ªùi ng·∫Øn g·ªçn b·∫±ng ti·∫øng Vi·ªát v·ªõi link k·∫øt qu·∫£.\n- N·∫øu thi·∫øu th√¥ng tin quan tr·ªçng, h·ªèi l·∫°i 1 c√¢u ng·∫Øn."
                }
            },
            "type": "@n8n/n8n-nodes-langchain.agent",
            "typeVersion": 3.1,
            "position": [
                448,
                400
            ],
            "id": "ai-agent",
            "name": "AI Agent Dispatcher"
        },
        {
            "parameters": {
                "description": "D√πng tool n√†y khi ng∆∞·ªùi d√πng g·ª≠i vƒÉn b·∫£n ho·∫∑c file .md/.txt ƒë·ªÉ xu·∫•t b·∫£n blog l√™n GitHub Pages.\n\nInput schema:\n- title (string): Ti√™u ƒë·ªÅ b√†i vi·∫øt\n- content (string): N·ªôi dung b√†i vi·∫øt (markdown/text)\n- fileId (string, optional): Telegram file_id n·∫øu g·ª≠i file\n- fileName (string, optional): T√™n file g·ªëc\n- tags (array, optional): Danh s√°ch tags\n- chatId (number): Chat ID ƒë·ªÉ g·ª≠i ph·∫£n h·ªìi\n\nOutput: success, postUrl, postId, postSlug, postTitle, message",
                "workflowId": {
                    "__rl": true,
                    "value": "REPLACE_WITH_BLOG_WORKFLOW_ID",
                    "mode": "id"
                },
                "workflowInputs": {
                    "mappingMode": "defineBelow",
                    "value": {
                        "title": "={{ $json.title }}",
                        "content": "={{ $json.content || $json.text }}",
                        "fileId": "={{ $json.fileId }}",
                        "fileName": "={{ $json.fileName }}",
                        "chatId": "={{ $json.chatId }}"
                    },
                    "matchingColumns": [],
                    "schema": [
                        {
                            "id": "title",
                            "displayName": "title",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "canBeUsedToMatch": true
                        },
                        {
                            "id": "content",
                            "displayName": "content",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "canBeUsedToMatch": true
                        },
                        {
                            "id": "fileId",
                            "displayName": "fileId",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "canBeUsedToMatch": true
                        },
                        {
                            "id": "fileName",
                            "displayName": "fileName",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "canBeUsedToMatch": true
                        },
                        {
                            "id": "chatId",
                            "displayName": "chatId",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "number",
                            "canBeUsedToMatch": true
                        }
                    ],
                    "attemptToConvertTypes": true,
                    "convertFieldsToString": false
                }
            },
            "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
            "typeVersion": 2.2,
            "position": [
                624,
                640
            ],
            "id": "tool-blog",
            "name": "Blog Publisher v2"
        },
        {
            "parameters": {
                "description": "D√πng tool n√†y khi ng∆∞·ªùi d√πng g·ª≠i audio/voice ƒë·ªÉ xu·∫•t b·∫£n podcast episode.\n\nInput schema:\n- fileId (string, required): Telegram file_id c·ªßa audio\n- fileName (string): T√™n file audio\n- title (string): Ti√™u ƒë·ªÅ episode (t·ª´ caption ho·∫∑c fileName)\n- description (string, optional): M√¥ t·∫£ episode\n- chatId (number): Chat ID ƒë·ªÉ g·ª≠i ph·∫£n h·ªìi\n\nOutput: success, episodeUrl, audioUrl, rssFeedUrl, message",
                "workflowId": {
                    "__rl": true,
                    "value": "REPLACE_WITH_PODCAST_WORKFLOW_ID",
                    "mode": "id"
                },
                "workflowInputs": {
                    "mappingMode": "defineBelow",
                    "value": {
                        "fileId": "={{ $json.fileId }}",
                        "fileName": "={{ $json.fileName }}",
                        "title": "={{ $json.title || $json.fileName?.replace(/\\.[^/.]+$/, '') }}",
                        "description": "={{ $json.text }}",
                        "chatId": "={{ $json.chatId }}"
                    },
                    "matchingColumns": [],
                    "schema": [
                        {
                            "id": "fileId",
                            "displayName": "fileId",
                            "required": true,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "canBeUsedToMatch": true
                        },
                        {
                            "id": "fileName",
                            "displayName": "fileName",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "canBeUsedToMatch": true
                        },
                        {
                            "id": "title",
                            "displayName": "title",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "canBeUsedToMatch": true
                        },
                        {
                            "id": "description",
                            "displayName": "description",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "string",
                            "canBeUsedToMatch": true
                        },
                        {
                            "id": "chatId",
                            "displayName": "chatId",
                            "required": false,
                            "defaultMatch": false,
                            "display": true,
                            "type": "number",
                            "canBeUsedToMatch": true
                        }
                    ],
                    "attemptToConvertTypes": true,
                    "convertFieldsToString": false
                }
            },
            "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
            "typeVersion": 2.2,
            "position": [
                816,
                640
            ],
            "id": "tool-podcast",
            "name": "Podcast Publisher v2"
        },
        {
            "parameters": {
                "chatId": "={{ $('Parse Telegram Message').first().json.chatId }}",
                "text": "={{ $json.output }}",
                "additionalFields": {
                    "parse_mode": "Markdown"
                }
            },
            "id": "telegram-reply",
            "name": "Telegram: Send Reply",
            "type": "n8n-nodes-base.telegram",
            "typeVersion": 1.2,
            "position": [
                672,
                400
            ],
            "credentials": {
                "telegramApi": {
                    "id": "EW2xjt48g5VAJ0M2",
                    "name": "Telegram account"
                }
            }
        }
    ],
    "connections": {
        "Listen for incoming events": {
            "main": [
                [
                    {
                        "node": "Parse Telegram Message",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "Parse Telegram Message": {
            "main": [
                [
                    {
                        "node": "AI Agent Dispatcher",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        },
        "OpenAI Chat Model": {
            "ai_languageModel": [
                [
                    {
                        "node": "AI Agent Dispatcher",
                        "type": "ai_languageModel",
                        "index": 0
                    }
                ]
            ]
        },
        "Blog Publisher v2": {
            "ai_tool": [
                [
                    {
                        "node": "AI Agent Dispatcher",
                        "type": "ai_tool",
                        "index": 0
                    }
                ]
            ]
        },
        "Podcast Publisher v2": {
            "ai_tool": [
                [
                    {
                        "node": "AI Agent Dispatcher",
                        "type": "ai_tool",
                        "index": 0
                    }
                ]
            ]
        },
        "AI Agent Dispatcher": {
            "main": [
                [
                    {
                        "node": "Telegram: Send Reply",
                        "type": "main",
                        "index": 0
                    }
                ]
            ]
        }
    },
    "pinData": {},
    "meta": {
        "templateCredsSetupCompleted": true,
        "instanceId": "80ff9b742c2b1d53f6055db1f4f1fadda9dee1113090f9bbb8307bf1dbd0b590"
    }
}